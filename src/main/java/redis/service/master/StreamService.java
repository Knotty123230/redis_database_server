package redis.service.master;

import redis.storage.RedisStorage;

import java.util.*;
import java.util.stream.Collectors;

public class StreamService {
    private final Map<String, Map<String, String>> stream;
    private static final StreamService streamService = new StreamService();
    private final Map<String, String> lastId = new HashMap<>();
    private final Map<String, String> autoGenerateIds = new HashMap<>();
    private final Map<String, String> autoGeneratedFullIds = new HashMap<>();
    private final RedisStorage redisStorage;
    private final StreamIdGenerator idGenerator;
    private final IdValidator idValidator;


    private StreamService() {
        stream = new HashMap<>();
        redisStorage = RedisStorage.getInstance();
        idGenerator = new StreamIdGenerator();
        idValidator = new IdValidator();
    }

    public static StreamService getInstance() {
        return streamService;
    }

    public List<Map<String, List<String>>> findValuesByStreamName(String name, List<String> streamKeys) {
        return findValues(name, streamKeys, ValueCondition.GREATER_OR_EQUAL);
    }

    public List<Map<String, List<String>>> findValuesNotBiggerThenId(String name, List<String> streamKeys) {
        return findValues(name, streamKeys, ValueCondition.LESS_OR_EQUAL);
    }

    public List<Map<String, List<String>>> findValuesBiggerThenId(String name, List<String> streamKeys) {
        return findValues(name, streamKeys, ValueCondition.GREATER);
    }

    public List<List<Map<String, Map<String, List<String>>>>> findValuesByStreamNameBiggerThenId(String name, List<String> command) {
        List<List<Map<String, Map<String, List<String>>>>> result = new ArrayList<>();
        List<Map<String, Map<String, List<String>>>> listNames = new LinkedList<>();
        Map<String, Map<String, List<String>>> mapNames = new HashMap<>();
        Map<String, List<String>> mapIds = new HashMap<>();
        Long startId = Long.parseLong(command.getFirst().split("-")[1]);
        Map<String, String> streamEntries = stream.get(name);
        for (Map.Entry<String, String> entry : streamEntries.entrySet()) {
            String href = entry.getValue();
            long key = Long.parseLong(entry.getKey().split("-")[1]);
            if (startId > key) continue;
            List<String> list = new LinkedList<>();
            String value = redisStorage.getCommand(href);
            list.add(href);
            list.add(value);
            mapIds.put(entry.getKey(), list);
        }
        mapNames.put(name, mapIds);
        listNames.add(mapNames);
        result.add(listNames);
        return result;
    }

    private enum ValueCondition {
        GREATER, LESS_OR_EQUAL, GREATER_OR_EQUAL
    }

    private List<Map<String, List<String>>> findValues(String name, List<String> streamKeys, ValueCondition condition) {
        List<Map<String, List<String>>> result = new ArrayList<>();
        Set<String> ids = getFirstPartOfId(streamKeys);
        String comparisonValue = condition == ValueCondition.LESS_OR_EQUAL ? getMaxValue(streamKeys) : getMinValue(streamKeys);
        Map<String, String> existsIdAndKey = stream.get(name);

        if (existsIdAndKey != null) {
            for (Map.Entry<String, String> entry : existsIdAndKey.entrySet()) {
                String[] split = entry.getKey().split("-");
                String existsKey = split[0];
                if (ids.contains(existsKey)) {
                    long entryId = Long.parseLong(split[1]);
                    long comparisonId = Long.parseLong(comparisonValue);
                    if (shouldSkip(entryId, comparisonId, condition)) continue;
                    result.add(createEntryMap(entry));
                }
            }
        }
        return result;
    }

    private boolean shouldSkip(long entryId, long comparisonId, ValueCondition condition) {
        return switch (condition) {
            case GREATER, GREATER_OR_EQUAL -> entryId < comparisonId;
            case LESS_OR_EQUAL -> entryId > comparisonId;
            default -> false;
        };
    }

    private Map<String, List<String>> createEntryMap(Map.Entry<String, String> entry) {
        String key = entry.getValue();
        String value = redisStorage.getCommand(key);
        List<String> keyValueList = new ArrayList<>();
        keyValueList.add(key);
        keyValueList.add(value);
        Map<String, List<String>> entryMap = new HashMap<>();
        entryMap.put(entry.getKey(), keyValueList);
        return entryMap;
    }


    private String getMaxValue(List<String> streamKeys) {
        return streamKeys
                .stream()
                .map(it -> it.split("-"))
                .map(it -> it[1])
                .max(Comparator.naturalOrder())
                .orElseThrow();
    }

    private static Set<String> getFirstPartOfId(List<String> streamKeys) {
        return streamKeys
                .stream()
                .map(it -> it.split("-")[0])
                .collect(Collectors.toSet());
    }

    private static String getMinValue(List<String> streamKeys) {
        return streamKeys.stream()
                .map(it -> it.split("-"))
                .map(it -> it[1])
                .sorted()
                .findFirst()
                .orElseThrow();
    }


    public String createStream(String name, String id, String key, String value) {
        System.out.println("CREATE STREAM: " + name + " " + id + " " + key + " " + value);

        if (stream.containsKey(name)) {
            return handleExistingStream(name, id, key, value);
        } else {
            return handleNewStream(name, id, key, value);
        }
    }

    private String handleExistingStream(String name, String id, String key, String value) {
        Map<String, String> storage = stream.get(name);
        if (autoGeneratedFullIds.containsKey(name)) {
            String authogeneratedFullID = autoGeneratedFullIds.get(name);
            long lastId = Long.parseLong(authogeneratedFullID.substring(authogeneratedFullID.length() - 1)) + 1;
            String generatedNewFullId = authogeneratedFullID.substring(0, authogeneratedFullID.length() - 1) + lastId;
            autoGeneratedFullIds.put(name, generatedNewFullId);
            storage.put(generatedNewFullId, key);
            redisStorage.save(key, value);
            return generatedNewFullId;
        }
        if (autoGenerateIds.containsKey(name)) {
            id = idGenerator.generateId(id, autoGenerateIds.get(name));
            autoGenerateIds.put(name, id);
            storage.put(id, key);
            redisStorage.save(key, value);
            return id;
        }

        String lastRecordId = lastId.get(name);
        System.out.println("existId = " + lastRecordId);
        String[] splitId = lastRecordId.split("-");
        String validationError = idValidator.validateId(id, splitId);

        if (validationError != null) {
            return validationError;
        }

        storage.put(id, key);
        lastId.put(name, id);
        redisStorage.save(key, value);
        return id;
    }

    private String handleNewStream(String name, String id, String key, String value) {
        HashMap<String, String> storage = new HashMap<>();
        if (id.length() == 1) {
            id = idGenerator.generateFullId();
            autoGeneratedFullIds.put(name, id);
        }
        if (id.endsWith("*")) {
            id = idGenerator.generateId(id, "");
            autoGenerateIds.put(name, id);
        }

        storage.put(id, key);
        redisStorage.save(key, value);
        stream.put(name, storage);
        lastId.put(name, id);
        return id;
    }


    public boolean streamExists(String name) {
        return stream.containsKey(name);
    }
}
