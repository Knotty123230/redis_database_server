package redis.service.master;

import redis.model.Result;
import redis.storage.RedisStorage;

import java.util.*;
import java.util.stream.Collectors;

public class StreamService {
    private static StreamService streamService;
    private final Map<String, Map<String, String>> stream;
    private final Map<String, String> lastId = new HashMap<>();
    private final Map<String, String> autoGenerateIds = new HashMap<>();
    private final Map<String, String> autoGeneratedFullIds = new HashMap<>();
    private final ExpireCommand expireCommand;
    private final RedisStorage redisStorage;
    private final StreamIdGenerator idGenerator;
    private final IdValidator idValidator;


    private StreamService() {
        System.out.println("INSTANCE OF STREAM SERVICE");
        stream = new HashMap<>();
        redisStorage = RedisStorage.getInstance();
        idGenerator = new StreamIdGenerator();
        idValidator = new IdValidator();
        expireCommand = new ExpireCommand();
    }

    public static StreamService getInstance() {
        synchronized (StreamService.class) {
            if (streamService == null) {
                streamService = new StreamService();
            }

            return streamService;
        }
    }

    private static Result getResult() {
        List<List<Map<String, Map<String, List<String>>>>> result = new ArrayList<>();
        List<Map<String, Map<String, List<String>>>> listNames = new LinkedList<>();
        Map<String, Map<String, List<String>>> mapNames = new HashMap<>();
        Map<String, List<String>> mapIds = new HashMap<>();
        return new Result(result, listNames, mapNames, mapIds);
    }

    private static Set<String> getFirstPartOfId(List<String> streamKeys) {
        return streamKeys
                .stream()
                .map(it -> it.split("-")[0])
                .collect(Collectors.toSet());
    }

    private static String getMinValue(List<String> streamKeys) {
        return streamKeys.stream()
                .map(it -> it.split("-"))
                .map(it -> it[1])
                .sorted()
                .findFirst()
                .orElseThrow();
    }

    public List<Map<String, List<String>>> findValuesByStreamName(String name, List<String> streamKeys) {
        return findValues(name, streamKeys, ValueCondition.GREATER_OR_EQUAL);
    }

    public List<Map<String, List<String>>> findValuesNotBiggerThenId(String name, List<String> streamKeys) {
        return findValues(name, streamKeys, ValueCondition.LESS_OR_EQUAL);
    }

    public List<Map<String, List<String>>> findValuesBiggerThenId(String name, List<String> streamKeys) {
        return findValues(name, streamKeys, ValueCondition.GREATER);
    }


    public List<List<Map<String, Map<String, List<String>>>>> findValuesByStreamNameBiggerThenId(List<String> names, List<String> command) {
        Result res = getResult();
        for (String name : names) {
            res.setMapNames(new HashMap<>());
            res.setMapIds(new HashMap<>());
            res.setListNames(new LinkedList<>());
            String id = command.isEmpty() ? "" : command.removeFirst();
            long startId = id.isEmpty() ? 0 : Long.parseLong(id.split("-")[1]);

            Map<String, String> streamEntries = stream.get(name);
            String string = streamEntries.keySet()
                    .stream()
                    .map(it -> it.split("-")[1])
                    .max(Comparator.naturalOrder())
                    .orElseThrow();
            System.out.println(string);
            for (Map.Entry<String, String> entry : streamEntries.entrySet()) {
                String href = entry.getValue();
                long key = Long.parseLong(entry.getKey().split("-")[1]);
                boolean a = startId == 0 ? key != Long.parseLong(string) : startId >= key;
                if (a) continue;
                List<String> list = new LinkedList<>();
                String value = redisStorage.getCommand(href);
                list.add(href);
                list.add(value);
                res.mapIds().put(entry.getKey(), list);
            }
            res.mapNames().put(name, res.mapIds());
            res.listNames().add(res.mapNames());
            res.result().add(res.listNames());
        }
        return res.result();
    }


    private List<Map<String, List<String>>> findValues(String name, List<String> streamKeys, ValueCondition condition) {
        List<Map<String, List<String>>> result = new ArrayList<>();
        Set<String> ids = getFirstPartOfId(streamKeys);
        String comparisonValue = condition == ValueCondition.LESS_OR_EQUAL ? getMaxValue(streamKeys) : getMinValue(streamKeys);
        Map<String, String> existsIdAndKey = stream.get(name);
        if (existsIdAndKey != null) {
            for (Map.Entry<String, String> entry : existsIdAndKey.entrySet()) {
                String[] split = entry.getKey().split("-");
                String existsKey = split[0];
                if (ids.contains(existsKey)) {
                    long entryId = Long.parseLong(split[1]);
                    long comparisonId = Long.parseLong(comparisonValue);
                    if (shouldSkip(entryId, comparisonId, condition)) continue;
                    result.add(createEntryMap(entry));
                }
            }
        }
        return result;
    }

    private boolean shouldSkip(long entryId, long comparisonId, ValueCondition condition) {
        return switch (condition) {
            case GREATER, GREATER_OR_EQUAL -> entryId < comparisonId;
            case LESS_OR_EQUAL -> entryId > comparisonId;
            default -> false;
        };
    }

    private Map<String, List<String>> createEntryMap(Map.Entry<String, String> entry) {
        String key = entry.getValue();
        String value = redisStorage.getCommand(key);
        List<String> keyValueList = new ArrayList<>();
        keyValueList.add(key);
        keyValueList.add(value);
        Map<String, List<String>> entryMap = new HashMap<>();
        entryMap.put(entry.getKey(), keyValueList);
        return entryMap;
    }

    private String getMaxValue(List<String> streamKeys) {
        return streamKeys
                .stream()
                .map(it -> it.split("-"))
                .map(it -> it[1])
                .max(Comparator.naturalOrder())
                .orElseThrow();
    }

    public String createStream(String name, String id, String key, String value) {
        System.out.println("CREATE STREAM: " + name + " " + id + " " + key + " " + value);
        if (stream.containsKey(name)) {
            return handleExistingStream(name, id, key, value);
        } else {
            return handleNewStream(name, id, key, value);
        }
    }

    private String handleExistingStream(String name, String id, String key, String value) {
        Map<String, String> storage = stream.get(name);
        if (autoGeneratedFullIds.containsKey(name)) {
            String autogeneratedFullID = autoGeneratedFullIds.get(name);
            long lastId = Long.parseLong(autogeneratedFullID.substring(autogeneratedFullID.length() - 1)) + 1;
            String generatedNewFullId = autogeneratedFullID.substring(0, autogeneratedFullID.length() - 1) + lastId;
            autoGeneratedFullIds.put(name, generatedNewFullId);
            storage.put(generatedNewFullId, key);
            redisStorage.save(key, value);
            return generatedNewFullId;
        }
        if (autoGenerateIds.containsKey(name)) {
            id = idGenerator.generateId(id, autoGenerateIds.get(name));
            autoGenerateIds.put(name, id);
            storage.put(id, key);
            redisStorage.save(key, value);
            return id;
        }

        String lastRecordId = lastId.get(name);
        System.out.println("existId = " + lastRecordId);
        String[] splitId = lastRecordId.split("-");
        String validationError = idValidator.validateId(id, splitId);

        if (validationError != null) {
            return validationError;
        }

        storage.put(id, key);
        lastId.put(name, id);
        redisStorage.save(key, value);
        return id;
    }

    private String handleNewStream(String name, String id, String key, String value) {
        HashMap<String, String> storage = new HashMap<>();
        if (id.length() == 1) {
            id = idGenerator.generateFullId();
            autoGeneratedFullIds.put(name, id);
        }
        if (id.endsWith("*")) {
            id = idGenerator.generateId(id, "");
            autoGenerateIds.put(name, id);
        }

        storage.put(id, key);
        redisStorage.save(key, value);
        stream.put(name, storage);
        lastId.put(name, id);
        return id;
    }

    public boolean streamExists(String name) {
        return stream.containsKey(name);
    }

    public ExpireCommand getExpireCommand() {
        return expireCommand;
    }

    private enum ValueCondition {
        GREATER, LESS_OR_EQUAL, GREATER_OR_EQUAL
    }
}
